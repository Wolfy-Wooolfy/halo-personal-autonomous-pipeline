# üìÑ Artifact Schema & Repository Layout Standard

**Version:** 1.2  
**Applies To:** All autonomous and semi-autonomous executions within the HALO Personal Autonomous Pipeline  
**Enforcement:** Mandatory (Fail-Closed)

---

## 1. Purpose

This document defines the **mandatory artifact structure, naming conventions, and repository layout**
used by the HALO Personal Autonomous Pipeline.

Its purpose is to ensure that:

- Every task produces **auditable, deterministic artifacts**
- Progress is **trackable without human interpretation**
- No stage may proceed without its required artifacts
- Autonomous execution never degenerates into unstructured output

This document is **binding** for:
- Autonomous agents
- Human-assisted execution
- Review, audit, and rollback operations

---

## 2. Core Principle

> **No artifact = No progress**

An execution stage is considered **not started** unless its input artifacts exist,  
and **not completed** unless its output artifacts are present and valid.

Artifacts are:
- Structured
- File-based
- Versionable
- Machine-verifiable

Free-form chat output has **zero authority**.

---

## 2.1 Artifact Authority Declaration

An artifact‚Äôs existence does NOT grant it authority.

An artifact is authoritative ONLY if:
- It is produced by its owning stage
- It passes the stage validation gate
- It is not rolled back or superseded
- It does not conflict with higher-authority documents

Artifacts that fail any of the above
MUST be treated as non-existent for execution purposes.

---

### 2.1.1 Artifact Presence vs Authority (Hard Rule)

The physical existence of an artifact
(granted by file presence)
does NOT imply execution authority.

An artifact has execution authority ONLY if:
- It is explicitly REQUIRED by the owning stage
- It passes the owning stage validation gate
- It passes Boundary Audit
- It is referenced by the pipeline state

Any artifact that exists without authority:
- MUST be ignored by execution logic
- MUST NOT influence decisions, progress, or retries
- MUST NOT be ‚Äúinterpreted‚Äù or ‚Äúconsidered‚Äù

Treating non-authoritative artifacts
as execution inputs
is a system violation.

---

### 2.1.2 No Implicit Authority Rule (Hard)

No artifact gains authority by:
- Existence
- Completeness
- Correct formatting
- Apparent relevance

Authority is granted ONLY through:
- Stage ownership
- Successful validation gate
- Boundary Audit PASS
- Explicit pipeline state reference

Any artifact not explicitly granted authority
MUST be treated as NON-EXISTENT
for all execution purposes.

---

## 2.2 Artifact Context Isolation Rule

An artifact is authoritative
ONLY within the task and execution context
that produced it.

Artifacts MUST NOT be:
- Reused across tasks
- Inherited by new executions
- Treated as globally valid

Reuse of content is allowed.
Reuse of authority is NOT.

Any artifact reused in a new task
must be re-validated
or regenerated by the owning stage.

Reusing artifact CONTENT does NOT grant execution authority.

If any artifact content is reused:
- It MUST be regenerated OR
- It MUST pass full validation in the new context

Implicit reuse of authority is forbidden.

No artifact may be treated as valid
outside the execution context
that produced and validated it.

An artifact MUST NOT influence execution
solely by its presence, completeness, or apparent relevance.

Artifacts that are:
- Not referenced by pipeline state
- Not required by the active stage
- Not granted authority by validation

MUST be treated as NON-EXISTENT
for all execution purposes.

---

### 2.2.1 Artifact Ghosting Prohibition (Hard)

Artifacts that exist outside
the active execution context
MUST NOT be:
- Read
- Parsed
- Interpreted
- Compared
- Used as reference

Presence of unrelated artifacts
in the repository
MUST have ZERO effect
on execution behavior.

Using historical or external artifacts
as implicit guidance
constitutes a system violation.

---

## 3. Mandatory Repository Layout

Every project or task MUST follow the directory structure below:

/<project-root>
‚îÇ
‚îú‚îÄ‚îÄ docs/
‚îÇ ‚îú‚îÄ‚îÄ 01_system/
‚îÇ ‚îú‚îÄ‚îÄ 02_scope/
‚îÇ ‚îú‚îÄ‚îÄ 03_pipeline/
‚îÇ ‚îú‚îÄ‚îÄ 04_autonomy/
‚îÇ ‚îú‚îÄ‚îÄ 05_artifacts/
‚îÇ ‚îú‚îÄ‚îÄ 06_progress/
‚îÇ ‚îú‚îÄ‚îÄ 07_decisions/
‚îÇ ‚îú‚îÄ‚îÄ 08_audit/
‚îÇ ‚îú‚îÄ‚îÄ 09_verify/
‚îÇ ‚îî‚îÄ‚îÄ 10_runtime/
‚îÇ
‚îú‚îÄ‚îÄ artifacts/
‚îÇ ‚îú‚îÄ‚îÄ stage_A/
‚îÇ ‚îú‚îÄ‚îÄ stage_B/
‚îÇ ‚îú‚îÄ‚îÄ stage_C/
‚îÇ ‚îî‚îÄ‚îÄ stage_D/
‚îÇ
‚îú‚îÄ‚îÄ code/
‚îÇ ‚îú‚îÄ‚îÄ src/
‚îÇ ‚îî‚îÄ‚îÄ tests/
‚îÇ
‚îú‚îÄ‚îÄ verify/
‚îÇ ‚îú‚îÄ‚îÄ smoke/
‚îÇ ‚îú‚îÄ‚îÄ unit/
‚îÇ ‚îî‚îÄ‚îÄ audit/
‚îÇ
‚îú‚îÄ‚îÄ decisions/
‚îÇ ‚îî‚îÄ‚îÄ DEC-YYYYMMDD-XXX.md
‚îÇ
‚îú‚îÄ‚îÄ progress/
‚îÇ ‚îú‚îÄ‚îÄ status.json
‚îÇ ‚îî‚îÄ‚îÄ history/
‚îÇ     ‚îî‚îÄ‚îÄ YYYY-MM-DD[_event].md
‚îÇ
‚îî‚îÄ‚îÄ README.md

Any deviation from this layout is a hard failure.

---

### Transitional Specification Folder (Non-Authoritative)

The folder `docs/B_specs/` is a TEMPORARY, NON-AUTHORITATIVE location.

Rules:
- Files under `docs/B_specs/` have ZERO execution authority
- They MUST NOT be treated as Stage B outputs
- They MUST NOT be consumed by Stage C or Stage D
- They exist solely as transitional drafting material

Authoritative Stage B specifications MUST live exclusively under:
- `artifacts/stage_B/`

Any file remaining under `docs/B_specs/` after Stage B closure
constitutes a repository compliance violation.

---

## 4. Artifact Categories

All artifacts fall into one of the following categories:

### 4.1 Documentation Artifacts (`/docs`)

Purpose:
- Define intent
- Define rules
- Define boundaries

Rules:
- Markdown only
- Deterministic language
- No speculative text

Naming:
```

NN_<short_title>.md

```

Example:
```

03_pipeline_stages.md

```

---

### 4.2 Code Artifacts (`/code`)

Purpose:
- Executable implementation of approved documentation

Rules:
- Code MUST map directly to one or more documents
- No orphan code allowed
- No experimental code outside scope

Structure:
- `/code/src`
- `/code/tests`

---

### 4.3 Verification Artifacts (`/verify`)

Purpose:
- Prove that execution matches intent

Types:
- Smoke checks
- Unit tests
- Contract assertions
- Audit validations

Rules:
- Tests must be runnable
- Failure must be explicit
- Silent failure is forbidden

---

### 4.4 Decision Artifacts (`/decisions`)

Purpose:
- Record authoritative, irreversible, or impactful choices

All decision artifacts:
- MUST live exclusively under `/decisions`
- MUST NOT be duplicated or summarized inside `/docs`
- MUST follow the Decision Logging & Change Traceability Specification

Documentation may reference Decision IDs,
but MUST NOT restate, paraphrase,
or reinterpret decision content.

Decision authority exists ONLY in `/decisions`.

---

## 4.5 Progress Artifacts

Progress artifacts represent the **authoritative execution state**
and are governed by strict isolation and authority rules.

Progress artifacts are divided into TWO
and ONLY TWO layers:

1. Live Execution State (Authoritative)  
2. Historical Records (Non-Authoritative)

No other progress representation is permitted.

Any file, view, or summary that does not fall
strictly into one of these two layers
has ZERO execution authority
and MUST NOT be read by any pipeline component.

---

## 4.5.1 Live Execution State (Authoritative)

The live execution state is represented by
ONE file and ONE file only:

`progress/status.json`

Rules:
- JSON format ONLY
- Single source of truth
- Always overwritten
- No append behavior
- No narration
- No human-readable commentary
- No duplicate representations

The runtime, pipeline, and agents MUST NOT:
- Read from any other progress file
- Derive state from historical snapshots
- Interpret human-readable summaries

Any reference to:
- `status.md`
- `status.txt`
- `status.yaml`
- Inline progress descriptions

is INVALID
and MUST be treated as a system defect.

---

## 4.5.2 Historical Snapshots (`progress/history/`)

Purpose:
- Preserve immutable execution history
- Support audit, replay, and rollback analysis

Rules:
- Read-only once written
- Never referenced for live execution decisions
- Created only on defined events

Snapshot creation triggers:
- Stage transition
- Decision finalization
- Failure followed by retry
- Full task completion

Naming format:
```

YYYY-MM-DD.md
YYYY-MM-DD_stage-transition.md
YYYY-MM-DD_failure-retry.md

```

Snapshots MUST NOT be edited or merged.

Historical snapshots exist exclusively
for audit and human inspection.

They MUST NOT:
- Be parsed
- Be compared
- Be used as input
- Be consulted for recovery
- Influence retries, rollbacks, or continuation

Execution logic MUST behave
as if historical snapshots do not exist.

---

### 4.5.2.1 History File Size & Rotation (Hard)

History files MUST remain bounded to prevent repository bloat.

Rules:
- Any single file under `progress/history/` MUST NOT exceed a finite configured size limit.
- The size limit MUST be explicitly configured in:
  - `progress/history/_rotation.json`
- The configuration file MUST contain exactly one field:
  - `max_file_bytes` (integer, > 0)
- If the configuration file is missing, invalid, or ambiguous:
  - Execution MUST Fail-Closed
  - The condition MUST be treated as a repository compliance fault

If a history event would exceed the limit, the snapshot MUST be split into multiple files using a deterministic suffix.

Naming:
- `YYYY-MM-DD[_event]_part-01.md`
- `YYYY-MM-DD[_event]_part-02.md`

Rotation rules:
- Rotation MUST NOT change content meaning.
- Rotation MUST NOT alter the authoritative live state.
- Rotation MUST NOT change event ordering.

History rotation exists for storage control ONLY and has ZERO execution authority.

---

## 4.5.3 Historical Artifacts Non-Authority Rule (Hard)

Artifacts under `progress/history/`:

- Are NON-authoritative
- MUST NOT be used for execution decisions
- MUST NOT influence retries, rollbacks, or continuation
- MUST NOT be read by agents to infer intent or state

They exist solely for:
- Audit
- Replay
- Post-mortem analysis

Any execution behavior derived from history artifacts
is a system violation.

---

## 5. Required Artifact Schema per Stage (Execution Artifacts)

This section defines the **task-scoped execution artifacts** that MUST exist
under `artifacts/` for each stage to claim progress.

Governance documents under `docs/` are NOT stage outputs.
Stage outputs are emitted ONLY under `artifacts/stage_<X>/`.

Missing required execution artifacts = stage failure.

---

### 5.1 Stage A ‚Äî Required Artifacts (`artifacts/stage_A/`)

Stage A MUST produce the following CLOSED artifacts:

- `artifacts/stage_A/task_plan.md`
- `artifacts/stage_A/validated_assumptions.md`
- `artifacts/stage_A/idea_evaluation.md`
- `artifacts/stage_A/idea_final_spec.md`
- `artifacts/stage_A/idea_approval_record.md`

No Stage B execution is permitted unless:
- `idea_final_spec.md` exists, AND
- `idea_approval_record.md` exists and indicates APPROVE.

---

### 5.2 Stage B ‚Äî Required Artifacts (`artifacts/stage_B/`)

Stage B MUST produce the following CLOSED artifacts:

- `artifacts/stage_B/specifications.md`
- `artifacts/stage_B/data_schemas.md`
- `artifacts/stage_B/interface_contracts.md`
- `artifacts/stage_B/validation_rules.md`
- `artifacts/stage_B/edge_cases.md`

Stage B MUST also produce the following CLOSED artifacts:

- `artifacts/stage_B/docs_gap_report.md`
- `artifacts/stage_B/docs_coverage_matrix.md`
- `artifacts/stage_B/spec_pack_manifest.md`

No Stage C execution is permitted unless:
- `docs_gap_report.md` indicates ZERO unresolved MUST-level gaps, AND
- `docs_coverage_matrix.md` indicates 100% MUST-level coverage, AND
- `spec_pack_manifest.md` exists and is consistent with the produced Stage B artifacts.

---

### 5.3 Stage C ‚Äî Required Artifacts (`artifacts/stage_C/` + code)

Stage C MUST produce code under:
- `/code/src/*`
- `/code/tests/*`

Stage C MUST also produce the following CLOSED artifacts:

- `artifacts/stage_C/code_trace_matrix.md`
- `artifacts/stage_C/code_mismatch_report.md`
- `artifacts/stage_C/test_evidence.md`

No Stage D execution is permitted unless:
- `code_mismatch_report.md` indicates ZERO unresolved mismatches, AND
- `code_trace_matrix.md` indicates 100% MUST-level coverage, AND
- `test_evidence.md` exists and indicates required tests PASS (as applicable).

---

### 5.4 Stage D ‚Äî Required Artifacts (`artifacts/stage_D/` + verify)

Stage D MUST produce CLOSED verification artifacts as required by:
- Build & Verify Playbook (Local)

At minimum, Stage D MUST produce:

- `artifacts/stage_D/verification_report.md`

If tests are executed within Stage D (per playbook), Stage D MUST also produce:

- `artifacts/stage_D/test_results.md` (or deterministic equivalent required by the playbook)

Stage D MUST NOT require, assume, or depend on a Decision artifact.

Decision artifacts may exist ONLY if:
- a selectable execution fork exists, AND
- a human-issued decision is required by contract, AND
- the decision is captured and logged by the orchestrator.

If applicable, Decision artifacts MUST live ONLY under:
- `/decisions/`

---

## 6. Naming Conventions

Rules:
- lowercase only
- underscores instead of spaces
- deterministic names
- no emojis
- no free text filenames

Bad:
```

final doc.md
test!!!.js

```

Good:
```

05_artifact_schema.md
user_validation.test.js

```

---

## 6.1 Stage Artifact Filename Constraints (Hard)

Within `artifacts/stage_A/`, `artifacts/stage_B/`, `artifacts/stage_C/`, `artifacts/stage_D/`:

- Filenames MUST be deterministic and stable
- Filenames MUST match the required artifacts list for the stage
- Additional files are allowed ONLY if:
  - they are explicitly required by a higher-authority contract, OR
  - they are explicitly required by the owning stage contract

Any extra artifact not permitted by contract:
- MUST be treated as a repository compliance violation
- MUST cause Fail-Closed unless it is proven non-authoritative AND ignored deterministically by execution logic

---

## 7. Artifact Immutability Rules

Once a pipeline stage is **CLOSED**:

- All artifacts produced by that stage become immutable
- The stage‚Äôs authority is permanently exhausted
- No artifact content may be altered, regenerated, or reinterpreted

Any change to a closed-stage artifact requires:
- An explicit Decision artifact, AND
- A full downstream invalidation per Pipeline Stages Specification

Silent overwrites are forbidden.

Exception:
`progress/status.json` is explicitly mutable by design
and governed exclusively by the Progress Tracking Contract.

No other artifact is mutable under any circumstances.

---

## 7.1 Forbidden Artifact Types

The pipeline MUST NOT generate, persist, or rely on:

- Draft artifacts
- Temporary notes
- Scratch files
- Partial schemas
- Exploratory documents

All persisted artifacts MUST be:
- Final
- Stage-owned
- Execution-relevant

If an artifact is not fit for execution,
it MUST NOT exist.

---

## 7.2 Artifact Mutation Detection Rule (Hard)

Any mutation of an immutable artifact
MUST be treated as a critical fault.

Mutation includes:
- File overwrite
- Partial content replacement
- Reordering content
- Silent regeneration

If mutation is detected:
- Execution MUST halt immediately
- The artifact MUST be invalidated
- Human escalation is REQUIRED

Silent artifact mutation
is equivalent to silent scope modification.

---

## 7.3 Artifact Deletion Prohibition (Hard)

Artifacts MUST NOT be deleted
once created.

Deletion is allowed ONLY if:
- A rollback decision explicitly mandates deletion, AND
- The deletion target is listed explicitly in the decision

Silent deletion,
cleanup,
or consolidation
of artifacts
is strictly forbidden.

An artifact may lose authority,
but MUST remain preserved
for audit and traceability.

---

## 8. Fail-Closed Enforcement

The pipeline MUST halt immediately if:
- A required artifact is missing
- An artifact violates schema
- A directory is malformed
- Naming rules are broken
- Live status contains historical content

Upon halt:

- If a valid owning-stage recovery path exists:
  - Execution MUST return to the owning stage
  - All downstream artifacts MUST be invalidated

- If NO valid recovery path exists:
  - Execution MUST transition to Execution Abort
  - Authority is exhausted
  - Human notification is REQUIRED

No retries without explicit rollback authority.

Fail-Closed enforcement is deterministic.
Interpretation is forbidden.

---

## 9. Authority Order (Hard-Aligned)

When conflicts occur, authority is resolved STRICTLY
and WITHOUT INTERPRETATION
according to the global pipeline authority hierarchy.

Authority precedence is as follows:

1. HALO Core Rules & Boundary Contracts  
2. Scope & Success Contract  
3. Autonomy Policy & Human Interrupt Protocol  
4. Pipeline Stages Specification  
5. HALO Boundary Audit Rules (Fail-Closed Pack)  
6. Progress Tracking & Status Report Contract (v1)  
7. Build & Verify Playbook (Local)  
8. Decision Logging & Change Traceability Specification  
9. This document (Artifact Schema & Repository Layout Standard)  
10. Tech Assumptions & Local Runtime Setup  
11. Stage-specific artifacts  
12. Code  
13. Runtime behavior  
14. Chat output (ZERO execution authority)

This document governs:
- Artifact structure
- Naming
- Layout
- Artifact authority mechanics

It does NOT override:
- Scope definitions
- Success criteria
- Autonomy rules
- Stage authority
- Decision authority
- Progress semantics

Lower-authority layers MUST NOT:
- Override higher layers
- Supplement missing rules
- Infer intent
- Resolve ambiguity

If a conflict cannot be resolved deterministically
using this order:
- Execution MUST halt
- Human escalation is REQUIRED

---

## 10. Completion Criteria

This document is considered ACTIVE and SATISFIED
ONLY when ALL of the following are true:

- Repository structure is enforced exactly as defined
- Live status and history separation is applied correctly
- All required artifacts exist and are authoritative
- No non-authoritative artifact influences execution
- Progress is readable deterministically
  without explanation, narration, or interpretation

If compliance requires explanation,
justification,
or verbal clarification,
then compliance does NOT exist.

---

**END OF DOCUMENT**