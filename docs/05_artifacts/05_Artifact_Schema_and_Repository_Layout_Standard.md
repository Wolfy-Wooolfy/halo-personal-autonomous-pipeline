# ğŸ“„ Artifact Schema & Repository Layout Standard

**Version:** 1.1  
**Applies To:** All autonomous and semi-autonomous executions within the HALO Personal Autonomous Pipeline  
**Enforcement:** Mandatory (Fail-Closed)

---

## 1. Purpose

This document defines the **mandatory artifact structure, naming conventions, and repository layout**
used by the HALO Personal Autonomous Pipeline.

Its purpose is to ensure that:

- Every task produces **auditable, deterministic artifacts**
- Progress is **trackable without human interpretation**
- No stage may proceed without its required artifacts
- Autonomous execution never degenerates into unstructured output

This document is **binding** for:
- Autonomous agents
- Human-assisted execution
- Review, audit, and rollback operations

---

## 2. Core Principle

> **No artifact = No progress**

An execution stage is considered **not started** unless its input artifacts exist,  
and **not completed** unless its output artifacts are present and valid.

Artifacts are:
- Structured
- File-based
- Versionable
- Machine-verifiable

Free-form chat output has **zero authority**.

---

## 2.1 Artifact Authority Declaration

An artifactâ€™s existence does NOT grant it authority.

An artifact is authoritative ONLY if:
- It is produced by its owning stage
- It passes the stage validation gate
- It is not rolled back or superseded
- It does not conflict with higher-authority documents

Artifacts that fail any of the above
MUST be treated as non-existent for execution purposes.

---

### 2.1.1 Artifact Presence vs Authority (Hard Rule)

The physical existence of an artifact
(granted by file presence)
does NOT imply execution authority.

An artifact has execution authority ONLY if:
- It is explicitly REQUIRED by the owning stage
- It passes the owning stage validation gate
- It passes Boundary Audit
- It is referenced by the pipeline state

Any artifact that exists without authority:
- MUST be ignored by execution logic
- MUST NOT influence decisions, progress, or retries
- MUST NOT be â€œinterpretedâ€ or â€œconsideredâ€

Treating non-authoritative artifacts
as execution inputs
is a system violation.

---

### 2.1.2 No Implicit Authority Rule (Hard)

No artifact gains authority by:
- Existence
- Completeness
- Correct formatting
- Apparent relevance

Authority is granted ONLY through:
- Stage ownership
- Successful validation gate
- Boundary Audit PASS
- Explicit pipeline state reference

Any artifact not explicitly granted authority
MUST be treated as NON-EXISTENT
for all execution purposes.

---

## 2.2 Artifact Context Isolation Rule

An artifact is authoritative
ONLY within the task and execution context
that produced it.

Artifacts MUST NOT be:
- Reused across tasks
- Inherited by new executions
- Treated as globally valid

Reuse of content is allowed.
Reuse of authority is NOT.

Any artifact reused in a new task
must be re-validated
or regenerated by the owning stage.

Reusing artifact CONTENT does NOT grant execution authority.

If any artifact content is reused:
- It MUST be regenerated OR
- It MUST pass full validation in the new context

Implicit reuse of authority is forbidden.

No artifact may be treated as valid
outside the execution context
that produced and validated it.

An artifact MUST NOT influence execution
solely by its presence, completeness, or apparent relevance.

Artifacts that are:
- Not referenced by pipeline state
- Not required by the active stage
- Not granted authority by validation

MUST be treated as NON-EXISTENT
for all execution purposes.

---

### 2.2.1 Artifact Ghosting Prohibition (Hard)

Artifacts that exist outside
the active execution context
MUST NOT be:
- Read
- Parsed
- Interpreted
- Compared
- Used as reference

Presence of unrelated artifacts
in the repository
MUST have ZERO effect
on execution behavior.

Using historical or external artifacts
as implicit guidance
constitutes a system violation.

---

## 3. Mandatory Repository Layout

Every project or task MUST follow the directory structure below:

/<project-root>
â”‚
â”œâ”€â”€ docs/
â”‚ â”œâ”€â”€ 01_system/
â”‚ â”œâ”€â”€ 02_scope/
â”‚ â”œâ”€â”€ 03_pipeline/
â”‚ â”œâ”€â”€ 04_autonomy/
â”‚ â”œâ”€â”€ 05_artifacts/
â”‚ â”œâ”€â”€ 06_progress/
â”‚ â”œâ”€â”€ 07_decisions/
â”‚ â”œâ”€â”€ 08_audit/
â”‚ â”œâ”€â”€ 09_verify/
â”‚ â””â”€â”€ 10_runtime/
â”‚
â”œâ”€â”€ artifacts/
â”‚ â”œâ”€â”€ stage_A/
â”‚ â”œâ”€â”€ stage_B/
â”‚ â”œâ”€â”€ stage_C/
â”‚ â””â”€â”€ stage_D/
â”‚
â”œâ”€â”€ code/
â”‚ â”œâ”€â”€ src/
â”‚ â””â”€â”€ tests/
â”‚
â”œâ”€â”€ verify/
â”‚ â”œâ”€â”€ smoke/
â”‚ â”œâ”€â”€ unit/
â”‚ â””â”€â”€ audit/
â”‚
â”œâ”€â”€ decisions/
â”‚ â””â”€â”€ DEC-YYYYMMDD-XXX.md
â”‚
â”œâ”€â”€ progress/
â”‚ â”œâ”€â”€ status.json
â”‚ â””â”€â”€ history/
â”‚     â””â”€â”€ YYYY-MM-DD[_event].md
â”‚
â””â”€â”€ README.md

Any deviation from this layout is a hard failure.

---

### Transitional Specification Folder (Non-Authoritative)

The folder `docs/B_specs/` is a TEMPORARY, NON-AUTHORITATIVE location.

Rules:
- Files under `docs/B_specs/` have ZERO execution authority
- They MUST NOT be treated as Stage B outputs
- They MUST NOT be consumed by Stage C or Stage D
- They exist solely as transitional drafting material

Authoritative Stage B specifications MUST live exclusively under:
- `artifacts/stage_B/`

Any file remaining under `docs/B_specs/` after Stage B closure
constitutes a repository compliance violation.

---

## 4. Artifact Categories

All artifacts fall into one of the following categories:

### 4.1 Documentation Artifacts (`/docs`)

Purpose:
- Define intent
- Define rules
- Define boundaries

Rules:
- Markdown only
- Deterministic language
- No speculative text

Naming:
```

NN_<short_title>.md

```

Example:
```

03_pipeline_stages.md

```

---

### 4.2 Code Artifacts (`/code`)

Purpose:
- Executable implementation of approved documentation

Rules:
- Code MUST map directly to one or more documents
- No orphan code allowed
- No experimental code outside scope

Structure:

/code/src
/code/tests

---

### 4.3 Verification Artifacts (`/verify`)

Purpose:
- Prove that execution matches intent

Types:
- Smoke checks
- Unit tests
- Contract assertions
- Audit validations

Rules:
- Tests must be runnable
- Failure must be explicit
- Silent failure is forbidden

---

### 4.4 Decision Artifacts (`/decisions`)

Purpose:
- Record authoritative, irreversible, or impactful choices

All decision artifacts:
- MUST live exclusively under `/decisions`
- MUST NOT be duplicated or summarized inside `/docs`
- MUST follow the Decision Logging & Change Traceability Specification

Documentation may reference Decision IDs,
but MUST NOT restate, paraphrase,
or reinterpret decision content.

Decision authority exists ONLY in `/decisions`.

---

## 4.5 Progress Artifacts

Progress artifacts represent the **authoritative execution state**
and are governed by strict isolation and authority rules.

Progress artifacts are divided into TWO
and ONLY TWO layers:

1. Live Execution State (Authoritative)
2. Historical Records (Non-Authoritative)

No other progress representation is permitted.

Any file, view, or summary that does not fall
strictly into one of these two layers
has ZERO execution authority
and MUST NOT be read by any pipeline component.

---

## 4.5.1 Live Execution State (Authoritative)

The live execution state is represented by
ONE file and ONE file only:

`progress/status.json`

Rules:
- JSON format ONLY
- Single source of truth
- Always overwritten
- No append behavior
- No narration
- No human-readable commentary
- No duplicate representations

The runtime, pipeline, and agents MUST NOT:
- Read from any other progress file
- Derive state from historical snapshots
- Interpret human-readable summaries

Any reference to:
- `status.md`
- `status.txt`
- `status.yaml`
- Inline progress descriptions

is INVALID
and MUST be treated as a system defect.

---

#### 4.5.2 Historical Snapshots (`progress/history/`)

Purpose:
- Preserve immutable execution history
- Support audit, replay, and rollback analysis

Rules:
- Read-only once written
- Never referenced for live execution decisions
- Created only on defined events

Snapshot creation triggers:
- Stage transition
- Decision finalization
- Failure followed by retry
- Full task completion

Naming format:
```

YYYY-MM-DD.md
YYYY-MM-DD_stage-transition.md
YYYY-MM-DD_failure-retry.md

```

Snapshots MUST NOT be edited or merged.

Historical snapshots exist exclusively
for audit and human inspection.

They MUST NOT:
- Be parsed
- Be compared
- Be used as input
- Be consulted for recovery
- Influence retries, rollbacks, or continuation

Execution logic MUST behave
as if historical snapshots do not exist.

---

### 4.5.2.1 History File Size & Rotation (Hard)

History files MUST remain bounded to prevent repository bloat.

Rules:
- Any single file under `progress/history/` MUST NOT exceed a finite configured size limit.
- The size limit MUST be explicitly configured in:
  - `progress/history/_rotation.json`
- The configuration file MUST contain exactly one field:
  - `max_file_bytes` (integer, > 0)
- If the configuration file is missing, invalid, or ambiguous:
  - Execution MUST Fail-Closed
  - The condition MUST be treated as a repository compliance fault

If a history event would exceed the limit, the snapshot MUST be split into multiple files using a deterministic suffix.

Naming:
- `YYYY-MM-DD[_event]_part-01.md`
- `YYYY-MM-DD[_event]_part-02.md`

Rotation rules:
- Rotation MUST NOT change content meaning.
- Rotation MUST NOT alter the authoritative live state.
- Rotation MUST NOT change event ordering.

History rotation exists for storage control ONLY and has ZERO execution authority.

---

### 4.5.3 Historical Artifacts Non-Authority Rule (Hard)

Artifacts under `progress/history/`:

- Are NON-authoritative
- MUST NOT be used for execution decisions
- MUST NOT influence retries, rollbacks, or continuation
- MUST NOT be read by agents to infer intent or state

They exist solely for:
- Audit
- Replay
- Post-mortem analysis

Any execution behavior derived from history artifacts
is a system violation.

---

## 5. Required Artifact Schema per Stage

Each pipeline stage MUST produce artifacts as follows:

| Stage | Required Artifacts |
|------|--------------------|
| A â€“ Architect | architecture/task_plan.md, architecture/validated_assumptions.md |
| B â€“ Docs Writer | docs/02_scope/*, docs/03_pipeline/* |
| C â€“ Builder | code/src/*, code/tests/* |
| D â€“ Verify | verify/* |
| D â€“ Decision (if applicable) | decisions/* |
| D â€“ Report | progress/status.json |

Notes:
- `docs/01_system/*`, `docs/04_autonomy/*`, `docs/05_artifacts/*`, `docs/06_progress/*`, and `docs/07_decisions/*`
  are governance documents and remain stable system-wide.
- Stage outputs listed above refer to task-scoped execution artifacts, not global governance documentation.

Missing artifacts = stage failure.

---

## 6. Naming Conventions

Rules:
- lowercase only
- underscores instead of spaces
- deterministic names
- no emojis
- no free text filenames

Bad:
```

Final Doc.md
test!!!.js

```

Good:
```

05_artifact_schema.md
user_validation.test.js

```

---

## 7. Artifact Immutability Rules

Once a pipeline stage is **CLOSED**:

- All artifacts produced by that stage become immutable
- The stageâ€™s authority is permanently exhausted
- No artifact content may be altered, regenerated, or reinterpreted

Any change to a closed-stage artifact requires:
- An explicit Decision artifact, AND
- A full downstream invalidation per Pipeline Stages Specification

Silent overwrites are forbidden.

Exception:
`progress/status.json` is explicitly mutable by design
and governed exclusively by the Progress Tracking Contract.

No other artifact is mutable under any circumstances.

---

## 7.1 Forbidden Artifact Types

The pipeline MUST NOT generate, persist, or rely on:

- Draft artifacts
- Temporary notes
- Scratch files
- Partial schemas
- Exploratory documents

All persisted artifacts MUST be:
- Final
- Stage-owned
- Execution-relevant

If an artifact is not fit for execution,
it MUST NOT exist.

---

### 7.2 Artifact Mutation Detection Rule (Hard)

Any mutation of an immutable artifact
MUST be treated as a critical fault.

Mutation includes:
- File overwrite
- Partial content replacement
- Reordering content
- Silent regeneration

If mutation is detected:
- Execution MUST halt immediately
- The artifact MUST be invalidated
- Human escalation is REQUIRED

Silent artifact mutation
is equivalent to silent scope modification.

---

### 7.3 Artifact Deletion Prohibition (Hard)

Artifacts MUST NOT be deleted
once created.

Deletion is allowed ONLY if:
- A rollback decision explicitly mandates deletion, AND
- The deletion target is listed explicitly in the decision

Silent deletion,
cleanup,
or consolidation
of artifacts
is strictly forbidden.

An artifact may lose authority,
but MUST remain preserved
for audit and traceability.

---

## 8. Fail-Closed Enforcement

The pipeline MUST halt immediately if:
- A required artifact is missing
- An artifact violates schema
- A directory is malformed
- Naming rules are broken
- Live status contains historical content

Upon halt:

- If a valid owning-stage recovery path exists:
  - Execution MUST return to the owning stage
  - All downstream artifacts MUST be invalidated

- If NO valid recovery path exists:
  - Execution MUST transition to Execution Abort
  - Authority is exhausted
  - Human notification is REQUIRED

No retries without explicit rollback authority.

Fail-Closed enforcement is deterministic.
Interpretation is forbidden.

---

## 9. Authority Order (Hard-Aligned)

When conflicts occur, authority is resolved STRICTLY
and WITHOUT INTERPRETATION
according to the global pipeline authority hierarchy.

Authority precedence is as follows:

1. HALO Core Rules & Boundary Contracts  
2. Scope & Success Contract  
3. Autonomy Policy & Human Interrupt Protocol  
4. Pipeline Stages Specification  
5. HALO Boundary Audit Rules (Fail-Closed Pack)  
6. Progress Tracking & Status Report Contract (v1)  
7. Build & Verify Playbook (Local)  
8. Decision Logging & Change Traceability Specification  
9. This document (Artifact Schema & Repository Layout Standard)  
10. Tech Assumptions & Local Runtime Setup  
11. Stage-specific artifacts  
12. Code  
13. Runtime behavior  
14. Chat output (ZERO execution authority)

This document governs:
- Artifact structure
- Naming
- Layout
- Artifact authority mechanics

It does NOT override:
- Scope definitions
- Success criteria
- Autonomy rules
- Stage authority
- Decision authority
- Progress semantics

Lower-authority layers MUST NOT:
- Override higher layers
- Supplement missing rules
- Infer intent
- Resolve ambiguity

If a conflict cannot be resolved deterministically
using this order:
- Execution MUST halt
- Human escalation is REQUIRED

---

## 10. Completion Criteria

This document is considered ACTIVE and SATISFIED
ONLY when ALL of the following are true:

- Repository structure is enforced exactly as defined
- Live status and history separation is applied correctly
- All required artifacts exist and are authoritative
- No non-authoritative artifact influences execution
- Progress is readable deterministically
  without explanation, narration, or interpretation

If compliance requires explanation,
justification,
or verbal clarification,
then compliance does NOT exist.

---

**END OF DOCUMENT**